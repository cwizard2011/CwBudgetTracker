import React, { createContext, useContext, useEffect, useState } from 'react';
import uuid from 'react-native-uuid';
import { Budget } from '../models/Budget';
import { LocalStorage } from '../services/LocalStorage';
import { syncService } from '../services/SyncService';

interface BudgetContextValue {
  budgets: Budget[];
  addBudget: (input: {
    title: string;
    amountPlanned: number;
    period: string; // YYYY-MM
    category?: string;
    categoryIcon?: string;
    recurring?: 'weekly' | 'monthly' | 'quarterly' | 'annually' | 'none';
    anchorDateISO?: string;
    dateISO?: string;
    recurringStopISO?: string;
    notes?: string;
    items: { id: string; name: string; amount: number, isCompleted: boolean }[];
  }) => Promise<void>;
  updateSpent: (budgetId: string, amountDelta: number) => Promise<void>;
  updateBudget: (budgetId: string, updates: Partial<Budget>) => Promise<void>;
  updateBudgetSingle: (budgetId: string, updates: Partial<Budget>) => Promise<void>;
  updateBudgetSeries: (budgetId: string, updates: Partial<Budget>) => Promise<void>;
  updateBudgetFuture: (budgetId: string, updates: Partial<Budget>) => Promise<void>;
  deleteBudget: (budgetId: string) => Promise<void>;
  deleteBudgetSingle: (budgetId: string) => Promise<void>;
  deleteBudgetSeries: (budgetId: string) => Promise<void>;
}

const BudgetContext = createContext<BudgetContextValue>({} as BudgetContextValue);

export const BudgetProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [budgets, setBudgets] = useState<Budget[]>([]);

  useEffect(() => {
    const load = async () => {
      const stored = await LocalStorage.getBudgets();
      setBudgets(stored);
    };
    load();
  }, []);

  function addDays(date: Date, days: number) {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + days);
    return d;
  }

  function addMonths(date: Date, months: number) {
    const d = new Date(date.getTime());
    d.setMonth(d.getMonth() + months);
    return d;
  }

  function addYears(date: Date, years: number) {
    const d = new Date(date.getTime());
    d.setFullYear(d.getFullYear() + years);
    return d;
  }

  function toISODate(d: Date) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
  }

  function toYearMonth(d: Date) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    return `${y}-${m}`;
  }

  const addBudget: BudgetContextValue['addBudget'] = async ({ title, amountPlanned, period, category, categoryIcon, recurring = 'none', anchorDateISO, dateISO, recurringStopISO, notes, items }) => {
    const now = Date.now();
    const baseId = uuid.v4().toString();
    const recurringGroupId = recurring && recurring !== 'none' ? baseId : undefined;

    const baseBudget: Budget = {
      id: baseId,
      title,
      amountPlanned,
      amountSpent: 0,
      period,
      category,
      categoryIcon,
      recurring,
      anchorDateISO,
      recurringStopISO,
      recurringGroupId,
      isAutoGenerated: false,
      notes,
      dateISO,
      createdAt: now,
      updatedAt: now,
      items,
    };

    let newItems: Budget[] = [baseBudget];

    // Auto-generate future occurrences when recurring with a stop date
    if (recurring && recurring !== 'none' && anchorDateISO && recurringStopISO) {
      try {
        const start = new Date(anchorDateISO);
        const end = new Date(recurringStopISO);
        if (!isNaN(start.getTime()) && !isNaN(end.getTime()) && end >= start) {
          let cursor = new Date(start.getTime());
          while (true) {
            // advance cursor
            switch (recurring) {
              case 'weekly':
                cursor = addDays(cursor, 7);
                break;
              case 'monthly':
                cursor = addMonths(cursor, 1);
                break;
              case 'quarterly':
                cursor = addMonths(cursor, 3);
                break;
              case 'annually':
                cursor = addYears(cursor, 1);
                break;
              default:
                cursor = addMonths(cursor, 1);
            }
            if (cursor > end) break;
            const occurrence: Budget = {
              ...baseBudget,
              id: uuid.v4().toString(),
              dateISO: toISODate(cursor),
              period: toYearMonth(cursor),
              isAutoGenerated: true,
              createdAt: now,
              updatedAt: now,
              amountSpent: 0,
            };
            newItems.push(occurrence);
          }
        }
      } catch {}
    }

    const next = [...budgets, ...newItems];
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    // enqueue for sync
    for (const item of newItems) {
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'create', payload: item });
    }
    syncService.start();
  };

  /* Update amount spent */
  const updateSpent: BudgetContextValue['updateSpent'] = async (budgetId, amountDelta) => {
    if (amountDelta === 0) return;
    const next = budgets.map(b =>
      b.id === budgetId
        ? { ...b, amountSpent: Math.max(0, b.amountSpent + amountDelta), updatedAt: Date.now() }
        : b,
    );
    const updated = next.find(b => b.id === budgetId);
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    if (updated) {
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'update', payload: updated });
    }
  };

  /* Update budget fields; when recurring fields change, regenerate auto-occurrences */
  const updateBudget: BudgetContextValue['updateBudget'] = async (budgetId, updates) => {
    const existing = budgets.find(b => b.id === budgetId);
    if (!existing) return;

    const merged: Budget = { ...existing, ...updates, updatedAt: Date.now() } as Budget;

    let working = budgets.slice();

    const scheduleChanged =
      'recurring' in updates || 'anchorDateISO' in updates || 'recurringStopISO' in updates || 'dateISO' in updates;

    if (scheduleChanged) {
      // Remove previous auto-generated occurrences for this series
      if (existing.recurringGroupId) {
        working = working.filter(b => !(b.recurringGroupId === existing.recurringGroupId && b.isAutoGenerated));
      }

      // Ensure group id
      const recurringGroupId = merged.recurring && merged.recurring !== 'none' ? (existing.recurringGroupId || existing.id) : undefined;
      merged.recurringGroupId = recurringGroupId;

      // Regenerate if we have a stop date and a recurrence rule
      const newItems: Budget[] = [];
      if (merged.recurring && merged.recurring !== 'none' && merged.anchorDateISO && merged.recurringStopISO) {
        try {
          const start = new Date(merged.anchorDateISO);
          const end = new Date(merged.recurringStopISO);
          if (!isNaN(start.getTime()) && !isNaN(end.getTime()) && end >= start) {
            let cursor = new Date(start.getTime());
            while (true) {
              switch (merged.recurring) {
                case 'weekly':
                  cursor = addDays(cursor, 7);
                  break;
                case 'monthly':
                  cursor = addMonths(cursor, 1);
                  break;
                case 'quarterly':
                  cursor = addMonths(cursor, 3);
                  break;
                case 'annually':
                  cursor = addYears(cursor, 1);
                  break;
                default:
                  cursor = addMonths(cursor, 1);
              }
              if (cursor > end) break;
              const occurrence: Budget = {
                ...merged,
                id: uuid.v4().toString(),
                dateISO: toISODate(cursor),
                period: toYearMonth(cursor),
                isAutoGenerated: true,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                amountSpent: 0,
              };
              newItems.push(occurrence);
            }
          }
        } catch {}
      }

      // Replace base and append regenerated items
      working = working.map(b => (b.id === budgetId ? merged : b));
      working = [...working, ...newItems];

      setBudgets(working);
      await LocalStorage.saveBudgets(working);
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'update', payload: merged });
      for (const item of newItems) {
        await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'create', payload: item });
      }
      return;
    }

    const next = working.map(b => (b.id === budgetId ? merged : b));
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'update', payload: merged });
  };

  /* Update only this occurrence; if part of a series, detach it */
  const updateBudgetSingle: BudgetContextValue['updateBudgetSingle'] = async (budgetId, updates) => {
    const existing = budgets.find(b => b.id === budgetId);
    if (!existing) return;
    const merged: Budget = {
      ...existing,
      ...updates,
      // Detach from series if applicable
      recurring: 'none',
      recurringGroupId: undefined,
      anchorDateISO: undefined,
      recurringStopISO: undefined,
      isAutoGenerated: false,
      updatedAt: Date.now(),
    } as Budget;
    const next = budgets.map(b => (b.id === budgetId ? merged : b));
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'update', payload: merged });
  };

  /* Update entire series; resolve base budget and call updateBudget */
  const updateBudgetSeries: BudgetContextValue['updateBudgetSeries'] = async (budgetId, updates) => {
    const existing = budgets.find(b => b.id === budgetId);
    if (!existing) return;
    const baseId = existing.recurringGroupId || existing.id;
    await updateBudget(baseId, updates);
  };

  /* Update only future occurrences (including the selected one) */
  const updateBudgetFuture: BudgetContextValue['updateBudgetFuture'] = async (budgetId, updates) => {
    const target = budgets.find(b => b.id === budgetId);
    if (!target) return;

    // If not a series, behave like single
    if ((!target.recurringGroupId && (!target.recurring || target.recurring === 'none'))) {
      await updateBudgetSingle(budgetId, updates);
      return;
    }

    const now = Date.now();
    const groupId = target.recurringGroupId || target.id;
    const cutoff = target.dateISO || `${target.period}-01`;

    // Remove all occurrences in the series with date >= cutoff, except the selected one itself
    const removed: Budget[] = [];
    let working = budgets.filter(b => {
      const inGroup = b.recurringGroupId === groupId;
      const dateIso = b.dateISO || `${b.period}-01`;
      const isFutureOrCurrent = dateIso >= cutoff;
      const isSelected = b.id === budgetId;
      const toRemove = inGroup && isFutureOrCurrent && !isSelected;
      if (toRemove) removed.push(b);
      return !toRemove;
    });

    // Update the selected occurrence as the new base for the future branch
    const existingIdx = working.findIndex(b => b.id === budgetId);
    if (existingIdx >= 0) {
      const merged: Budget = {
        ...working[existingIdx],
        ...updates,
        recurringGroupId: groupId,
        isAutoGenerated: false,
        updatedAt: now,
      } as Budget;
      working[existingIdx] = merged;

      // If still recurring, regenerate occurrences after cutoff based on possibly updated rule
      const recurrence = merged.recurring;
      const stopISO = merged.recurringStopISO;
      const anchorISO = merged.dateISO || cutoff;
      const itemsToAppend: Budget[] = [];
      if (recurrence && recurrence !== 'none' && stopISO) {
        try {
          let cursor = new Date(anchorISO);
          const end = new Date(stopISO);
          while (true) {
            switch (recurrence) {
              case 'weekly':
                cursor = addDays(cursor, 7);
                break;
              case 'monthly':
                cursor = addMonths(cursor, 1);
                break;
              case 'quarterly':
                cursor = addMonths(cursor, 3);
                break;
              case 'annually':
                cursor = addYears(cursor, 1);
                break;
              default:
                cursor = addMonths(cursor, 1);
            }
            if (cursor > end) break;
            const occ: Budget = {
              ...merged,
              id: uuid.v4().toString(),
              dateISO: toISODate(cursor),
              period: toYearMonth(cursor),
              isAutoGenerated: true,
              createdAt: now,
              updatedAt: now,
              amountSpent: 0,
            };
            itemsToAppend.push(occ);
          }
        } catch {}
      }

      const next = [...working, ...itemsToAppend];
      setBudgets(next);
      await LocalStorage.saveBudgets(next);
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'update', payload: working[existingIdx] });
      for (const del of removed) {
        await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'delete', payload: del });
      }
      for (const item of itemsToAppend) {
        await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'create', payload: item });
      }
      return;
    }
  };

  /* Delete budget */
  const deleteBudget: BudgetContextValue['deleteBudget'] = async budgetId => {
    const target = budgets.find(b => b.id === budgetId);
    if (!target) return;
    let next: Budget[];
    // If deleting a base recurring budget, also remove auto-generated siblings in the same series
    if (target.recurringGroupId && !target.isAutoGenerated) {
      next = budgets.filter(b => b.recurringGroupId !== target.recurringGroupId);
    } else {
      next = budgets.filter(b => b.id !== budgetId);
    }
    const deleted = target;
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    if (deleted) {
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'delete', payload: deleted });
    }
  };

  /* Delete only this occurrence */
  const deleteBudgetSingle: BudgetContextValue['deleteBudgetSingle'] = async budgetId => {
    const target = budgets.find(b => b.id === budgetId);
    if (!target) return;
    const next = budgets.filter(b => b.id !== budgetId);
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'delete', payload: target });
  };

  /* Delete entire series */
  const deleteBudgetSeries: BudgetContextValue['deleteBudgetSeries'] = async budgetId => {
    const target = budgets.find(b => b.id === budgetId);
    if (!target) return;
    const groupId = target.recurringGroupId || target.id;
    const next = budgets.filter(b => b.recurringGroupId !== groupId);
    setBudgets(next);
    await LocalStorage.saveBudgets(next);
    // enqueue delete for each removed item for sync
    for (const removed of budgets.filter(b => b.recurringGroupId === groupId)) {
      await LocalStorage.enqueueMutation({ collection: 'budgets', type: 'delete', payload: removed });
    }
  };

  return (
    <BudgetContext.Provider value={{ budgets, addBudget, updateSpent, updateBudget, updateBudgetSingle, updateBudgetSeries, updateBudgetFuture, deleteBudget, deleteBudgetSingle, deleteBudgetSeries }}>
      {children}
    </BudgetContext.Provider>
  );
};

export const useBudgets = () => useContext(BudgetContext);
